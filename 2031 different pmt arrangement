// 6 x 4 pmts with correct dimension
   /*  if (fMcpLayout == 2031) {

    // =========================
    // Geometry parameters
    // =========================
    fMcpTotal[0] = 61.5;   // Y dimension (height)
    fMcpTotal[1] = 60.0;   // X dimension (width)
    fMcpTotal[2] = 1.0;    // thickness

    fMcpActive[0] = 53.0;  // Active height
    fMcpActive[1] = 53.0;  // Active width
    fMcpActive[2] = 1.0;

    fLens[0] = fLens[1] = fPrizm[3];
    fLens[2] = 12.0;
    fRadius   = 770.5;
    fNBoxes   = 16;
    fBoxWidth = fPrizm[0];  // mother volume width (Y)

    // MCP logical volume
    G4Box *gMcp = new G4Box("gMcp", fMcpTotal[0]/2., fMcpTotal[1]/2., fMcpTotal[2]/2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp");

    // Pixel configuration
    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix2);

    G4Box *gPixel = new G4Box("gPixel",
                              0.5 * fMcpActive[0] / fNpix1,
                              0.5 * fMcpActive[1] / fNpix2,
                              0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel");

    int pixId = 0;
    for (int i = 0; i < fNpix1; i++) {
        for (int j = 0; j < fNpix2; j++) {
            double shiftx = (i + 0.5) * (fMcpActive[0] / fNpix1) - 0.5 * fMcpActive[0];
            double shifty = (j + 0.5) * (fMcpActive[1] / fNpix2) - 0.5 * fMcpActive[1];
            new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0),
                              lPixel, "wPixel", lMcp, false, pixId++);
        }
    }

    // =========================
    // MCP placement: 6 rows × 4 columns
    // =========================
    fNCol = 4; // columns in X direction
    fNRow = 6; // rows in Y direction

    double gapx = 1.0; // gap between columns
    double gapy = 1.0; // gap between rows

    int mcpId = 0;

    // Compute total array size
    double totalWidth  = fNCol * fMcpTotal[0] + (fNCol - 1) * gapx;   // in X
    double totalHeight = fNRow * fMcpTotal[1] + (fNRow - 1) * gapy;   // in Y

    std::cout << "Total MCP area (X,Y): " << totalWidth << " x " << totalHeight << std::endl;
    std::cout << "Mother box width (Y): " << fBoxWidth << std::endl;

    // Loop over columns and rows
    for (int i = 0; i < fNCol; i++) {
        double shiftx = -0.5 * totalWidth + i * (fMcpTotal[0] + gapx) + 0.5 * fMcpTotal[0];
        for (int j = 0; j < fNRow; j++) {
            double shifty = -0.5 * totalHeight + j * (fMcpTotal[1] + gapy) + 0.5 * fMcpTotal[1];

            std::cout << "Placing MCP " << mcpId
                      << " at (X,Y) = (" << shiftx << ", " << shifty << ")" << std::endl;

            new G4PVPlacement(0,
                              G4ThreeVector(shiftx, shifty, 0),
                              lMcp,
                              "wMcp",
                              lFd,
                              false,
                              mcpId++);
        }
    }
}*/


// 23 pmts and last colm shifted in the middle
/*if (fMcpLayout == 2031) {

    // =========================
    // Geometry parameters
    // =========================
    fMcpTotal[0] = 61.5;   // Y dimension (height)
    fMcpTotal[1] = 60.0;   // X dimension (width)
    fMcpTotal[2] = 1.0;    // thickness

    fMcpActive[0] = 53.0;  // Active height
    fMcpActive[1] = 53.0;  // Active width
    fMcpActive[2] = 1.0;

    fLens[0] = fLens[1] = fPrizm[3];
    fLens[2] = 12.0;
    fRadius   = 770.5;
    fNBoxes   = 16;
    fBoxWidth = fPrizm[0];  // mother volume width (Y)

    // MCP logical volume
    G4Box *gMcp = new G4Box("gMcp", fMcpTotal[0]/2., fMcpTotal[1]/2., fMcpTotal[2]/2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp");

    // Pixel configuration
    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix2);

    G4Box *gPixel = new G4Box("gPixel",
                              0.5 * fMcpActive[0] / fNpix1,
                              0.5 * fMcpActive[1] / fNpix2,
                              0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel");

    int pixId = 0;
    for (int i = 0; i < fNpix1; i++) {
        for (int j = 0; j < fNpix2; j++) {
            double shiftx = (i + 0.5) * (fMcpActive[0] / fNpix1) - 0.5 * fMcpActive[0];
            double shifty = (j + 0.5) * (fMcpActive[1] / fNpix2) - 0.5 * fMcpActive[1];
            new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0),
                              lPixel, "wPixel", lMcp, false, pixId++);
        }
    }

    // =========================
    // MCP placement: 4 columns × (6 or 5 rows)
    // =========================
    fNCol = 4; // columns in X
    fNRow = 6; // max rows in Y

    double gapx = 1.0; // gap between columns
    double gapy = 1.0; // gap between rows

    int mcpId = 0;

    // Total width based on max number of rows
    double totalWidth  = fNCol * fMcpTotal[0] + (fNCol - 1) * gapx;
    double totalHeight = fNRow * fMcpTotal[1] + (fNRow - 1) * gapy;

    std::cout << "Total MCP area (X,Y): " << totalWidth << " x " << totalHeight << std::endl;

    for (int i = 0; i < fNCol; i++) {

        // Column 0 is shorter (5 PMTs), others full (6 PMTs)
        int pmtsInCol = (i == 0) ? (fNRow - 1) : fNRow;

        // X center position
        double shiftx = -0.5 * totalWidth + i * (fMcpTotal[0] + gapx) + 0.5 * fMcpTotal[0];

        // Column height
        double colHeight = pmtsInCol * fMcpTotal[1] + (pmtsInCol - 1) * gapy;

        // Vertically centered offset
        double offsetY = -0.5 * colHeight;

        if (pmtsInCol < fNRow) {
            std::cout << "Column " << i << " has " << pmtsInCol << " PMTs (shorter, centered vertically)." << std::endl;
        }

        for (int j = 0; j < pmtsInCol; j++) {
            double shifty = offsetY + j * (fMcpTotal[1] + gapy) + 0.5 * fMcpTotal[1];

            std::cout << "Placing MCP " << mcpId
                      << " at (X,Y) = (" << shiftx << ", " << shifty << ")" << std::endl;

            new G4PVPlacement(0,
                              G4ThreeVector(shiftx, shifty, 0),
                              lMcp,
                              "wMcp",
                              lFd,
                              false,
                              mcpId++);
        }
    }
}*/
    
    // mcp 5 x 4 stack in the middle
   /* if (fMcpLayout == 2031) {

    // =========================
    // Geometry parameters
    // =========================
    fMcpTotal[0] = 61.5;   // Y dimension (height)
    fMcpTotal[1] = 60.0;   // X dimension (width)
    fMcpTotal[2] = 1.0;    // thickness

    fMcpActive[0] = 53.0;  // Active height
    fMcpActive[1] = 53.0;  // Active width
    fMcpActive[2] = 1.0;

    fLens[0] = fLens[1] = fPrizm[3];
    fLens[2] = 12.0;
    fRadius   = 770.5;
    fNBoxes   = 16;
    fBoxWidth = fPrizm[0];

    // MCP logical volume
    G4Box *gMcp = new G4Box("gMcp", fMcpTotal[0]/2., fMcpTotal[1]/2., fMcpTotal[2]/2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp");

    // Pixel configuration (16x16)
    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix2);

    G4Box *gPixel = new G4Box("gPixel",
                              0.5 * fMcpActive[0] / fNpix1,
                              0.5 * fMcpActive[1] / fNpix2,
                              0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel");

    int pixId = 0;
    for (int i = 0; i < fNpix1; i++) {
        for (int j = 0; j < fNpix2; j++) {
            double shiftx = (i + 0.5) * (fMcpActive[0] / fNpix1) - 0.5 * fMcpActive[0];
            double shifty = (j + 0.5) * (fMcpActive[1] / fNpix2) - 0.5 * fMcpActive[1];
            new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0),
                              lPixel, "wPixel", lMcp, false, pixId++);
        }
    } */

    // =========================
    // MCP placement: 4 columns × 5 rows (20 PMTs)
    // =========================
  /*  fNCol = 4; // columns in X
    fNRow = 5; // rows in Y

    double gapx = 1.0; // gap between columns
    double gapy = 1.0; // gap between rows

    int mcpId = 0;

    double totalWidth  = fNCol * fMcpTotal[0] + (fNCol - 1) * gapx;
    double totalHeight = fNRow * fMcpTotal[1] + (fNRow - 1) * gapy;

    std::cout << "Total MCP area (X,Y): " << totalWidth << " x " << totalHeight << std::endl;

    // All columns have same number of rows (5)
    for (int i = 0; i < fNCol; i++) {

        double shiftx = -0.5 * totalWidth + i * (fMcpTotal[0] + gapx) + 0.5 * fMcpTotal[0];

        double colHeight = fNRow * fMcpTotal[1] + (fNRow - 1) * gapy;
        double offsetY = -0.5 * colHeight;

        for (int j = 0; j < fNRow; j++) {
            double shifty = offsetY + j * (fMcpTotal[1] + gapy) + 0.5 * fMcpTotal[1];

            std::cout << "Placing MCP " << mcpId
                      << " at (X,Y) = (" << shiftx << ", " << shifty << ")" << std::endl;

            new G4PVPlacement(0,
                              G4ThreeVector(shiftx, shifty, 0),
                              lMcp,
                              "wMcp",
                              lFd,
                              false,
                              mcpId++);
        }
    }

    std::cout << "Total MCPs placed: " << mcpId << std::endl;
} */
    
    
    // 5 x 4 symmetrically distributed
if (fMcpLayout == 2031 || fMcpLayout == 2032) {

    // =========================
    // Geometry parameters
    // =========================
    fMcpTotal[0] = 61.5;   // Y dimension (height)
    fMcpTotal[1] = 60.0;   // X dimension (width)
    fMcpTotal[2] = 1.0;    // thickness

    fMcpActive[0] = 53.0;  // Active height
    fMcpActive[1] = 53.0;  // Active width
    fMcpActive[2] = 1.0;

    fLens[0] = fLens[1] = fPrizm[3];
    fLens[2] = 12.0;
    fRadius   = 770.5;
    fNBoxes   = 16;
    fBoxWidth = fPrizm[0];

    // =========================
    // MCP logical volume
    // =========================
    G4Box *gMcp = new G4Box("gMcp", fMcpTotal[0]/2., fMcpTotal[1]/2., fMcpTotal[2]/2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp", 0, 0, 0);

    // =========================
    // MCP Pixel configuration (16x16)
    // =========================
    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix2);

    G4Box *gPixel = new G4Box("gPixel",
                               0.5 * fMcpActive[0]/fNpix1,
                               0.5 * fMcpActive[1]/fNpix2,
                               0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel", 0, 0, 0);

    int pixId = 0;
    for (int i=0; i<fNpix1; i++) {
        for (int j=0; j<fNpix2; j++) {
            double shiftx = (i + 0.5) * (fMcpActive[0]/fNpix1) - 0.5*fMcpActive[0];
            double shifty = (j + 0.5) * (fMcpActive[1]/fNpix2) - 0.5*fMcpActive[1];
            new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0),
                              lPixel, "wPixel", lMcp, false, pixId++);
        }
    }

    // =========================
    // MCP placement: 4 columns × 5 rows
    // =========================
    fNCol = 4; // along X
    fNRow = 5; // along Y

    // Compute gaps dynamically to fit MCP array inside mother volume
    double gapX = (fFd[1] - fNCol * fMcpTotal[1]) / (fNCol + 1);
    double gapY = (fFd[0] - fNRow * fMcpTotal[0]) / (fNRow + 1);

    int mcpId = 0;
    for (int i=0; i<fNCol; i++) {
        double shiftX = -0.5*fFd[1] + gapX + i*(fMcpTotal[1] + gapX) + 0.5*fMcpTotal[1];
        for (int j=0; j<fNRow; j++) {
            double shiftY = -0.5*fFd[0] + gapY + j*(fMcpTotal[0] + gapY) + 0.5*fMcpTotal[0];
            new G4PVPlacement(0, G4ThreeVector(shiftX, shiftY, 0),
                              lMcp, "wMcp", lFd, false, mcpId++);
        }
    }

    std::cout << "Total MCPs placed: " << mcpId << std::endl;
}
