 if (fMcpLayout == 2031) {
    // alternative mcp pmt
    // The MCP  5x 4 symmetrical arrangement  leaving symmetrical space on both sides

    // fMcpTotal[1]=fPrizm[0]/6.-1;
    // fMcpTotal[0]=fPrizm[2]/4.-5;
    // fMcpActive[1]= fMcpTotal[1];
    // fMcpActive[0]= fMcpTotal[0];

    G4Box *gMcp = new G4Box("gMcp", fMcpTotal[0] / 2., fMcpTotal[1] / 2., fMcpTotal[2] / 2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp", 0, 0, 0);

    // double pixSize = 6*mm;
    // fNpix1 = 32; // fMcpActive[1]/pixSize-1;
    // fNpix2 = 32; // fMcpActive[1]/pixSize-1;

    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix1);
    // fRun->setTest2(fMcpActive[0] / fNpix1);

    int mcpId = 0;
    int pixId = 0;
    double gapx = (fPrizm[2] - fNCol * fMcpTotal[0]) / (double)(fNCol + 1);
    double gapy = (fBoxWidth - fNRow * fMcpTotal[1]) / (double)(fNRow + 1);    
    
    std::cout << "fNpix1=" << fNpix1 << " fNpix2=" << fNpix2 << " size = " << fMcpActive[0] / fNpix1
              << std::endl;

    // The MCP Pixel
    G4Box *gPixel =
      new G4Box("gPixel", 0.5 * fMcpActive[0] / fNpix1, 0.5 * fMcpActive[1] / fNpix2, 0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel", 0, 0, 0);

    for (int i = 0; i < fNpix1; i++) {
      for (int j = 0; j < fNpix2; j++) {
        double shiftx = (i + 0.5) * (fMcpActive[0] / fNpix1) - 0.5 * fMcpActive[0];
        double shifty = (j + 0.5) * (fMcpActive[1] / fNpix2) - 0.5 * fMcpActive[1];
        new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0), lPixel, "wPixel", lMcp, false,
                          pixId++);
      }
    }

    for (int i = 0; i < fNCol; i++) {
      for (int j = 1; j < fNRow; j++) {
        // double shiftx = i*(fMcpTotal[0]+gapx)-0.5*(fPrizm[3]-fMcpTotal[0])+gapx;
        // double shifty = j*(fMcpTotal[1]+gapy)-0.5*(fBoxWidth-fMcpTotal[1])+gapy;
        // new
        // G4PVPlacement(0,G4ThreeVector(shiftx,shifty,0.5*dirclength+fPrizm[1]+fMcpActive[2]/2.+fLens[2]),lMcp,"wMcp",
        // lDirc,false,mcpId++);
        double shiftx = (i - 0.5 * (fNCol - 1)) * (fMcpTotal[0] + gapx);
        double shifty = (j - 1 - 0.5 * (fNRow - 2)) * (fMcpTotal[1] + gapy);
        //double shiftx = i * (fMcpTotal[0] + gapx) - 0.5 * (fFd[1] - fMcpTotal[0]) + gapx;
        //double shifty = j * (fMcpTotal[1] + gapy) - 0.5 * (fBoxWidth - fMcpTotal[1]) + gapy;
	// shifty += 0.5*fMcpTotal[0];
        new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0), lMcp, "wMcp", lFd, false, mcpId++);
      }
    }
    } 
    
// 5 x 4 pmts
   if (fMcpLayout == 2031) {
    // alternative mcp pmt
    // The MCP

    // fMcpTotal[1]=fPrizm[0]/6.-1;
    // fMcpTotal[0]=fPrizm[2]/4.-5;
    // fMcpActive[1]= fMcpTotal[1];
    // fMcpActive[0]= fMcpTotal[0];
    fNRow = 5;
    fNCol = 4;

    G4Box *gMcp = new G4Box("gMcp", fMcpTotal[0] / 2., fMcpTotal[1] / 2., fMcpTotal[2] / 2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp", 0, 0, 0);

    // double pixSize = 6*mm;
    // fNpix1 = 32; // fMcpActive[1]/pixSize-1;
    // fNpix2 = 32; // fMcpActive[1]/pixSize-1;

    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix1);
    // fRun->setTest2(fMcpActive[0] / fNpix1);

    int mcpId = 0;
    int pixId = 0;
    //double gapx = (fPrizm[2] - fNCol * fMcpTotal[0]) / (double)(fNCol + 1);
    double gapx = 1;
    double gapy = (fBoxWidth - fNRow * fMcpTotal[1]) / (double)(fNRow + 1);    
    std::cout << "gap x = " << gapx << "" << "gapy = " << gapy << std::endl;
    
    std::cout << "fNpix1=" << fNpix1 << " fNpix2=" << fNpix2 << " size = " << fMcpActive[0] / fNpix1
              << std::endl;

    // The MCP Pixel
    G4Box *gPixel =
      new G4Box("gPixel", 0.5 * fMcpActive[0] / fNpix1, 0.5 * fMcpActive[1] / fNpix2, 0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel", 0, 0, 0);

    for (int i = 0; i < fNpix1; i++) {
      for (int j = 0; j < fNpix2; j++) {
        double shiftx = (i + 0.5) * (fMcpActive[0] / fNpix1) - 0.5 * fMcpActive[0];
        double shifty = (j + 0.5) * (fMcpActive[1] / fNpix2) - 0.5 * fMcpActive[1];
        new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0), lPixel, "wPixel", lMcp, false,
                          pixId++);
      }
    }

    for (int i = 0; i < fNCol; i++) {
      for (int j = 0; j < fNRow; j++) {
        // double shiftx = i*(fMcpTotal[0]+gapx)-0.5*(fPrizm[3]-fMcpTotal[0])+gapx;
        // double shifty = j*(fMcpTotal[1]+gapy)-0.5*(fBoxWidth-fMcpTotal[1])+gapy;
        // new
        // G4PVPlacement(0,G4ThreeVector(shiftx,shifty,0.5*dirclength+fPrizm[1]+fMcpActive[2]/2.+fLens[2]),lMcp,"wMcp",
        // lDirc,false,mcpId++);

        double shiftx = i * (fMcpTotal[0] + gapx) - 0.5 * (fFd[1] - fMcpTotal[0]) + gapx;
        double shifty = j * (fMcpTotal[1] + gapy) - 0.5 * (fBoxWidth - fMcpTotal[1]) + gapy;
	// shifty += 0.5*fMcpTotal[0];
        new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0), lMcp, "wMcp", lFd, false, mcpId++);
      }
    }
  } 


// updated pmt arrangement 
   if (fMcpLayout == 2031) {
    // MCP dimensions (active area + frame)
    double mcpX = 61.5;   // mm
    double mcpY = 60;   // mm
    double mcpZ = fMcpTotal[2]; // keep existing thickness

    G4Box* gMcp = new G4Box("gMcp", mcpX/2., mcpY/2., mcpZ/2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp", 0, 0, 0);

    // MCP pixels
    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix2);

    G4Box* gPixel = new G4Box("gPixel", 0.5 * mcpX / fNpix1, 0.5 * mcpY / fNpix2, 0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel", 0, 0, 0);

    int pixId = 0;
    for (int i = 0; i < fNpix1; i++) {
        for (int j = 0; j < fNpix2; j++) {
            double shiftx = (i + 0.5) * (mcpX / fNpix1) - 0.5 * mcpX;
            double shifty = (j + 0.5) * (mcpY / fNpix2) - 0.5 * mcpY;
            new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0), lPixel, "wPixel", lMcp, false, pixId++);
        }
    }

    // Full detector plane half-sizes
    double fFdHalfX = fFd[1] / 2.;    // full FD X-size / 2
    double fFdHalfY = fBoxWidth / 2.; // full FD Y-size / 2

    // Grid parameters
    int nCols = 4;
    int nRows = 6;
   // double gapX = (fFd[1] - nCols * mcpX) / (nCols + 1);
    //double gapY = (fBoxWidth - nRows * mcpY) / (nRows + 1);
    double gapX = 1;
    double gapY = 1;

    double totalWidthX = nCols * mcpX + (nCols - 1) * gapX;
    double totalHeightY = nRows * mcpY + (nRows - 1) * gapY;

    double stickX = (fFdHalfX - totalWidthX)/2.;
    double stickY = (fFdHalfY - totalHeightY)/2.;

    std::cout << "gapx = " << gapX <<""<< "gapy = " << gapY << std::endl; 

    std::cout << "=== MCP Symmetric Stick-out (full sensor including frame) ===" << std::endl;
    std::cout << "X: " << stickX << " mm, Y: " << stickY << " mm" << std::endl;

    // Active area only
    double activeX = 53.0;
    double activeY = 53.0;
    double totalActiveWidthX = nCols * activeX + (nCols - 1) * gapX;
    double totalActiveHeightY = nRows * activeY + (nRows - 1) * gapY;

    double stickActiveX = (fFdHalfX - totalActiveWidthX)/2.;
    double stickActiveY = (fFdHalfY - totalActiveHeightY)/2.;

    std::cout << "=== MCP Symmetric Stick-out (active area only) ===" << std::endl;
    std::cout << "X: " << stickActiveX << " mm, Y: " << stickActiveY << " mm" << std::endl;

    // Place MCPs in grid 6 x 4 pmts
 /*   int mcpId = 0;
    for (int i = 0; i < nCols; i++) {
        for (int j = 0; j < nRows; j++) {
            double shiftX = -0.5 * totalWidthX + gapX + i * (mcpX + gapX) + mcpX / 2.;
            double shiftY = -0.5 * totalHeightY + gapY + j * (mcpY + gapY) + mcpY / 2.;
            new G4PVPlacement(0, G4ThreeVector(shiftX, shiftY, 0), lMcp, "wMcp", lFd, false, mcpId++);
        }
    }
} */

// Place MCPs in grid 23 pmts but last pmts removed and all other pmts in their place
int mcpId = 0;
for (int i = 0; i < nCols; i++) {
    for (int j = 0; j < nRows; j++) {

        // Remove only one MCP: bottom-left corner (i=0, j=0)
        if (i == 0 && j == 0) continue;

        double shiftX = -0.5 * totalWidthX + gapX + i * (mcpX + gapX) + mcpX / 2.;
        double shiftY = -0.5 * totalHeightY + gapY + j * (mcpY + gapY) + mcpY / 2.;

        new G4PVPlacement(
            0,
            G4ThreeVector(shiftX, shiftY, 0),
            lMcp,
            "wMcp",
            lFd,
            false,
            mcpId++
        );
    }
}
}


// Alternative MCP-PMT layout (fMcpLayout == 2031) 6 full pmts and last col 5  pmts stick together at middle.
/*if (fMcpLayout == 2031) {

    // =========================
    // Geometry parameters
    // =========================
    fMcpTotal[0] = 61.5;   // Y-dimension (mm)
    fMcpTotal[1] = 60.0;   // X-dimension (mm)
    fMcpTotal[2] = 1.0;    // thickness (mm)

    fMcpActive[0] = 53.0;  // Active area (Y)
    fMcpActive[1] = 53.0;  // Active area (X)
    fMcpActive[2] = 1.0;

    fLens[0] = fLens[1] = fPrizm[3];  // lens size tied to prism thickness
    fLens[2] = 12.0;                  // lens thickness (mm)

    fRadius   = 770.5;   // lens radius
    fNBoxes   = 16;      // number of divisions
    fBoxWidth = fPrizm[0];  // width of mother volume

    // =========================
    // Logical volume for a single MCP
    // =========================
    G4Box *gMcp = new G4Box("gMcp", fMcpTotal[0]/2., fMcpTotal[1]/2., fMcpTotal[2]/2.);
    lMcp = new G4LogicalVolume(gMcp, BarMaterial, "lMcp");

    // MCP pixels (16x16)
    fNpix1 = 16;
    fNpix2 = 16;
    fRun->setNpix(fNpix1 * fNpix2);

    G4Box *gPixel = new G4Box("gPixel",
                              0.5 * fMcpActive[0]/fNpix1,
                              0.5 * fMcpActive[1]/fNpix2,
                              0.01);
    lPixel = new G4LogicalVolume(gPixel, BarMaterial, "lPixel");

    int pixId = 0;
    for (int i = 0; i < fNpix1; i++) {
        for (int j = 0; j < fNpix2; j++) {
            double shiftx = (i + 0.5) * (fMcpActive[0]/fNpix1) - 0.5 * fMcpActive[0];
            double shifty = (j + 0.5) * (fMcpActive[1]/fNpix2) - 0.5 * fMcpActive[1];
            new G4PVPlacement(0, G4ThreeVector(shiftx, shifty, 0),
                              lPixel, "wPixel", lMcp, false, pixId++);
        }
    }

    // =========================
    // MCP placement
    // =========================
    int mcpId = 0;

    // Half-height of mother volume
    double lFdHalfY = 0.5 * fBoxWidth;

    // Compute total MCP width
    double totalWidth = fNCol * fMcpTotal[0];

    // Define gaps (you can tune)
    double gapx = 1.0;
    double gapy = 1.0;

    for (int i = 0; i < fNCol; i++) {
        int pmtsInCol = (i == 0) ? (fNRow - 1) : fNRow;  // first column shorter

        // X position (centered)
        double shiftx = -0.5 * totalWidth + gapx + i * (fMcpTotal[0] + gapx) + 0.5 * fMcpTotal[0];

        // Column height including gaps
        double colHeight = pmtsInCol * fMcpTotal[1] + (pmtsInCol - 1) * gapy;

        // Bottom offset
        double offsetY = -0.5 * colHeight;

        if (pmtsInCol < fNRow) {
            std::cout << "Column " << i << " shorter: offsetY = " << offsetY << std::endl;
            std::cout << "Inactive space at bottom: " << lFdHalfY - (colHeight/2)
                      << ", top: " << lFdHalfY - (colHeight/2) << std::endl;
        }

        // Place MCPs in column
        for (int j = 0; j < pmtsInCol; j++) {
            double shifty = offsetY + j * (fMcpTotal[1] + gapy) + 0.5 * fMcpTotal[1];
            std::cout << "Placing MCP " << mcpId
                      << " at X,Y = " << shiftx << ", " << shifty << std::endl;

            new G4PVPlacement(0,
                              G4ThreeVector(shiftx, shifty, 0),
                              lMcp,
                              "wMcp",
                              lFd,
                              false,
                              mcpId++);
        }
    }
}*/
